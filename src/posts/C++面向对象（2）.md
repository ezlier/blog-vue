---
title: C++面向对象(2)继承、多态与虚函数
date: 2025-08-25 18:12:35
tags: [C++,进阶]
image: 'cover/cover-16.jpg'
---

# 类的继承

继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行效率的效果。

当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为**基类**（父类），新建的类称为**派生类**（子类）。

派生类继承基类的成员变量和成员函数，且可以有自己的成员变量和成员函数。

在 C++ 中，对父类成员的权限，子类中可以进行重新的定义，这个定义就是通过继承时候写的public 来实现的。

```c++
//基类
class Animal {
    void eat(){};
    int foot;
};

//派生类
class Dog : public Animal {
    void bark(){};
};
```

tips：在类名后加final可以使这个类不能被继承。

---------------------

# 多态

为了让不同类型有多种相应状态，这个现象叫多态。

假如我们在子类和父类中都定义一个同名函数

```c++
#include "iostream"
using namespace std;

//基类
class Animal {
public:
    void eat(){
        cout << "Animal eat";
    };

};

//派生类
class Dog : public Animal {
public:
    void eat(){
        cout << "dog eat";
    };
};

int main(){
    Dog *dog = new Dog();
    dog->eat();
    Animal *an = (Animal *)dog;
    an->eat();
    delete dog;
    return 0;
}
```

运行时可以发现两次eat()输出不同。这是因为非虚函数是静态绑定，函数调用在编译时就根据**指针类型**确定了。

-------------------

# 虚函数

如果要实现函数动态绑定，就需要使用虚函数。

```c++
#include "iostream"
using namespace std;

//基类
class Animal {
public:
    //在函数前加virtual
    virtual void eat(){
        cout << "Animal eat";
    };

};

//派生类
class Dog : public Animal {
public:
    //在()后面加override重写虚函数
    void eat() override {
        cout << "dog eat";
    };
};

void goeat(Animal &an){
    an.eat();
};

int main(){
    Dog dog;
    goeat(dog);
    return 0;
}
```

goeat()函数会根据传进来的变量找到函数

每个对象都会有一个虚函数表用于执行实际类型所对应的那个虚函数的地址。

## 析构函数与 virtual

当基类的析构函数不是虚函数时，通过基类指针删除派生类对象会导致**派生类的析构函数不被调用**，从而产生资源泄漏。

```c++
class Staff {
public:
    std::string name;
    int age;
    
    ~Staff() {  // ❌ 非虚析构函数
        std::cout << "Staff destructor" << std::endl;
    }
};

class Coder : public Staff {
public:
    std::string language;
    
    ~Coder() {  // ❌ 不会被调用
        std::cout << "Coder destructor" << std::endl;
    }
};

int main() {
    Staff* s = new Coder();  // 基类指针指向派生类对象
    delete s;  // 只调用 Staff 的析构函数！
    return 0;
}
```

当析构函数是虚函数时，通过基类指针删除对象会**先调用派生类的析构函数**，然后**自动调用基类的析构函数**。

如果不是虚函数，则根据指针类型进行**静态绑定**，只调用基类的析构函数。

**黄金规则**：如果一个类有可能被继承，并且会通过基类指针来删除对象，那么**基类的析构函数必须是虚函数**。这是 C++ 中最重要的编程准则之一！

----------------------------

# 智能指针

使用 new 关键字将一个对象分配到堆上，分配到堆上的对象必须手动 delete 掉，否则就会造成内存泄漏的问题。我们常常因为忘记释放内存，或者释放内存的时机不对而出现问题。

为了可以让指针自行释放，在 C++11 标准中，加入了一种可以自行释放的指针，叫做智能指针。

## unique_ptr

独占所有权的智能指针，同一时间只能有一个 `unique_ptr` 指向特定内存。

```c++
#include <iostream>
#include <memory>  // 必须包含这个头文件

class Resource {
public:
    Resource() { std::cout << "Resource acquired\n"; }
    ~Resource() { std::cout << "Resource destroyed\n"; }
    void doSomething() { std::cout << "Doing something...\n"; }
};

int main() {
    // 创建 unique_ptr
    std::unique_ptr<Resource> ptr1 = std::make_unique<Resource>();
    ptr1->doSomething();
    
    // 移动语义（所有权转移）
    std::unique_ptr<Resource> ptr2 = std::move(ptr1);
    
    if (!ptr1) {
        std::cout << "ptr1 is now null (ownership moved)\n";
    }
    
    // ptr2 离开作用域时自动释放内存
    return 0;
}
```

## shared_ptr

共享所有权的智能指针，多个 `shared_ptr` 可以指向同一内存，内存在最后一个 `shared_ptr` 被销毁时释放。

```c++
#include <iostream>
#include <memory>

class Object {
public:
    Object() { std::cout << "Object created\n"; }
    ~Object() { std::cout << "Object destroyed\n"; }
};

int main() {
    // 创建 shared_ptr（推荐使用 make_shared）
    std::shared_ptr<Object> ptr1 = std::make_shared<Object>();
    
    {
        // 共享所有权
        std::shared_ptr<Object> ptr2 = ptr1;
        std::cout << "Use count: " << ptr2.use_count() << std::endl;  // 输出: 2
    } // ptr2 离开作用域，引用计数减1
    
    std::cout << "Use count: " << ptr1.use_count() << std::endl;  // 输出: 1
    
    return 0;
} // ptr1 离开作用域，引用计数为0，对象被销毁
```

## weak_ptr

弱引用智能指针，用于与 `shared_ptr` 配合使用，避免循环引用导致的内存泄漏。

```c++
#include <iostream>
#include <memory>

class Node {
public:
    std::shared_ptr<Node> next;
    std::weak_ptr<Node> prev;

    Node() : next(nullptr), prev() {}
};

int main() {
    std::shared_ptr<Node> node1 = std::make_shared<Node>();
    std::shared_ptr<Node> node2 = std::make_shared<Node>();

    node1->next = node2;
    node2->prev = node1;

    // 循环引用，但使用 weak_ptr 避免了内存泄漏
    return 0;
}
```

若不使用 `weak_ptr` ，两个 `shared_ptr` 互相指向对方，从而造成死锁。
