---
title: 数据结构
date: 2025-08-28 17:31:45
tags: 随笔
image: 'cover/cover-18.png'
---

# 数据结构的基本概念

数据：所有能够输入到计算机中的描述客观事物的符号，包括文本、声音、图像、符号等。  
数据项：有独立含义的数据最小单位，也称域。若干个数据项构成一个数据元素，数据项是不可分割的最小单位。  
数据元素：数据的基本单位，也称节点或记录。  
数据类型：数据不可分割的单位。  

# 逻辑结构和存储结构

逻辑结构：数据元素间抽象化的相互关系，与数据的存储无关，独立于计算机，它是从具体问题中抽象出来的数学模型。  
	逻辑结构有集合、线性结构、树形结构、图形结构。  
存储结构：数据元素及其关系在计算机中的存储方式。  
	存储结构可以分为4种：顺序存储、链式存储、散列存储和索引存储。

常用:

- 顺序结构：在计算机开辟连续的空间，它通过存储单元的邻接关系来体现数据元素之间的逻辑关系。  
- 链式存储：不连续，有一个指针存放下一个节点的地址。

---------------------------------------

# 线性表的顺序表示和实现

## 线性表的类型定义

由n(n>=0)个相同类型的数据元素组成的有限序列，是最基本最常用的一种线性结构。  
线性表有唯一的开始和结束，除了第一和最后一个元素，每个元素都有一个唯一的直接前驱(前一个数据)和直接后继(后一个数)。

### 顺序表的定义

顺序表采用顺序存储方式，即逻辑上相邻的数据在计算机内的存储位置也是相邻的。顺序存储方式，元素存储是连续的，中间不允许有空，可以快速定位第几个元素，但是插入和删除时需要移动大量元素。

```c++
//初始化
bool InitList(SqList &L){
	L.elem = new int[Maxsize];
	if (!L.elem) return false;
	L.length = 0;
	return true;
}

//创建
bool CreateList(SqList &L) {
    int x;
    L.length = 0;  // 确保从0开始
    while (true) {
        cin >> x;
        if (x == -1) break;  // 终止条件
        if (L.length >= Maxsize) {
            cout << "表已满";
            return false;
        }
        L.elem[L.length] = x;  // 直接使用length作为索引
        L.length++;
    }
    return true;
}

//取值
bool GetElem(SqList L,int i,int &e){
    if(i<1||i>L.length) return false;
    e=L.elem[i-1];   //下标从0开始，则第i个元素下标为i-1
    return true;
}

//插入
bool ListInsert_Sq(SqList &L,int i,int e){
    if(i<1||i>L.length+1) return false;
    if (L.length >= Maxsize) return false;
    for(int j=L.length-1;j>=i-1;j--)
        L.elem[j+1] = L.elem[j];
    L.elem[i-1] = e;
    L.length++;
    return true;
}

//删除
bool ListDelete_Sq(SqList &L,int i,int &e){
    if(i<1||i>L.length+1) return false;
    e = L.elem[i-1];
    for (int j=i;j <= L.length-1;j++)
        L.elem[j-1] = L.elem[j];
    L.length--;
    return true;
}
```

--------------

### 单链表的定义

每个节点包含两个域：数据域和指针域。数据域存储数据元素，指针域存储下一个节点的地址，因此指针指向的类型也是节点类型。每个指针都指向下一个节点，都是朝一个方向，这样的链表称为单链表。

```c++
//头插法创建单链表(输入顺序与链表顺序相反)
void CreateList_H(LinkList &L){
	int n;
    LinkList s;
    L = new LNode;
    L->next = NULL;
    cin >> n;
    while(n--){
        s = new LNode;
        cin >> s->data;
        s->next = L->next;   // 新结点指向原第一个结点
        L->next = s;	  	// 头结点指向新结点
    }
}

//尾插法创建单链表(输入输出顺序一致)
void CreateList_R(LinkList &L){
    int n;
    LinkList s,r;
    L = new LNode;
    L->next = NULL;
    r = L;
    cin >> n;
    while(n--){
    s = new LNode;      // 创建新结点
    cin >> s->data;     // 输入数据到新结点
    s->next = NULL;     // 新结点next置空
    r->next = s;        // 尾结点指向新结点
    r = s;              // 更新尾指针
    }
}

//查找
bool LocateElem_L(LinkList L,int e){
    LinkList p;
    p = L->next;
    while(p&&p->data != e)
        p = p->next;
    if(!p)
        return false;
    return true;
}

// 在第pos个位置插入新结点（从1开始计数）
bool insertAtPosition(LinkList &L, int pos, int value) {
    if (pos < 1) return false;  // 位置合法性检查
    // 找到插入位置的前驱结点
    LNode* prev = L;
    int count = 0;
    while (prev != NULL && count < pos - 1) {
        prev = prev->next;
        count++;
    }
    if (prev == NULL) {  // 位置超出范围
        cout << "插入位置无效" << endl;
        return false;
    }
    LNode* newNode = new LNode;
    newNode->data = value;
    newNode->next = prev->next;  // 新结点指向后继
    prev->next = newNode;        // 前驱指向新结点
    return true;
}

//删除
bool ListDelete_L(LinkList &L,int i){
    LinkList p,q;
    int j;
    p = L;
    j = 0;
    while(p->next && j < i-1){
        p = p->next;
        j++;
    }
    if(!p->next || j > i-1)
        return false;
    q = p->next;        // q指向要删除的结点
    p->next = q->next;  // 绕过要删除的结点
    delete q;
    return true;
}
```

--------------

### 双向链表

为了操作方便，可以给每个元素附加两个指针域，一个存储前一个元素的地址，另一个存储下一个元素的地址，这种链表称为双向链表。

### 循环链表

最后一个节点的指针指向头节点的链表。

---------------------

## 线性表的应用

1、合并有序顺序表

```c++
void mergesqlist(SqList La,SqList Lb,SqList &Lc){
	int i,j,k;
    i=j=k=0;
    Lc.length = La.length + Lb.length;
    Lc.elem = new int[Lc.length];
    while (i < La.length && j < Lb.length){
        if (La.elem[i] <= Lb.elem[j])
            Lc.elem[k++] = La.elem[i++];  // 先赋值再自增
        else
        	Lc.elem[k++] = Lb.elem[j++];
    }
    while (i < La.length){
        Lc.elem[k++] = La.elem[i++];
    }
    while (j < Lb.length){
        Lc.elem[k++] = Lb.elem[j++];
    }
}
```

2、合并有序链表

```c++
void mergeLinkList(LinkList La, LinkList Lb, LinkList &Lc) {
    LinkList p, q, r;
    p = La->next;
    q = Lb->next;
    Lc = La;
    r = Lc;
    while (p && q) {
        if (p->data <= q->data) {
            r->next = p;
            r = p;
            p = p->next;
        } else {
            r->next = q;
            r = q;
            q = q->next;
        }
    }
    if (p) {
        r->next = p;
    } else {
        r->next = q;
    }
    delete Lb;
}
```

3、逆置单链表

```c++
void reverselinklist(LinkList &L){
	LinkList p,q;
    p = L->next;
    L->next = NULL;
    while(p){
        q = p->next;
        p->next = L->next;
        L->next = p;
        p = q;
    }
}
```

4、查找链表中间节点

```c++
LinkList findmiddle(LinkList L){
    LinkList p,q;
    p = L;
    q = L;
    while(p != NULL && p->next != NULL){
        p = p->next->next;
        q = q->next;
    }
    return q;
}
```

---------------------------

# 栈

栈的类型定义：先进后出的线性序列。栈是一种线性表，但只能在一端进出操作。进出的一端称为栈顶（top），另一端称为栈底（base）。栈可以顺序存储，也可以链式存储，分为顺序栈和链栈。

顺序栈

```c++
#define MAXSIZE 100  // 栈的最大容量
typedef struct {
    int data[MAXSIZE];  // 存储栈元素
    int top;            // 栈顶指针
} SqStack;

// 初始化
void InitStack(SqStack &S) {
    S.top = -1;  // 栈空标志
}

// 入栈
bool Push(SqStack &S, int e) {
    if (S.top == Maxsize - 1) {
        cout << "栈已满，无法入栈" << endl;
        return false;
    }
    S.data[++S.top] = e;  // 栈顶指针先加1，再存入元素
    return true;
}

// 出栈
bool Pop(SqStack &S, int &e) {
    if (S.top == -1) {
        cout << "栈为空，无法出栈" << endl;
        return false; 
    }
    e = S.data[S.top--];  // 先取出元素，栈顶指针再减1
    return true;
}

//取栈顶元素
bool GetTop(SqStack S, int &e) {
    if (S.top == -1) {
        cout << "栈为空" << endl;
        return false;
    }
    e = S.data[S.top];  // 获取栈顶元素，不修改指针
    return true;
}
```

链栈

```c++
typedef struct StackNode {
    int data;
    struct StackNode* next;
} StackNode, *LinkStack;

// 初始化
void InitStack(LinkStack &S) {
    S = NULL;  // 空栈
}

// 入栈
bool Push(LinkStack &S, int e) {
    StackNode* newNode = new StackNode;
    newNode->data = e;
    newNode->next = S;  // 新结点指向原栈顶
    S = newNode;        // 更新栈顶指针
    return true;
}

// 出栈
bool Pop(LinkStack &S, int &e) {
    if (S == NULL) {
        cout << "栈为空，无法出栈" << endl;
        return false;
    }
    StackNode* temp = S;
    e = S->data;
    S = S->next;    // 栈顶指针下移
    delete temp;    // 释放原栈顶结点
    return true;
}

// 取顶
bool GetTop(LinkStack S, int &e) {
    if (S == NULL) {
        cout << "栈为空" << endl;
        return false;
    }
    e = S->data;
    return true;
}
```

------------

# 队列

定义：先进先出的线性序列，只能在两端操作。

## 顺序队列

队列的顺序存储采用一段连续的空间存储数据元素，并用两个整型变量记录对头和队尾的下标。

```c++
#define Maxsize 100
typedef struct SqQueue{
	Elemtype data[Maxsize];
    int front,rear;
}SqQueue;

// 初始化
void InitQueue(SqQueue &Q) {
    Q.front = 0;
    Q.rear = 0;  // 队空条件：front == rear
}

// 入队
bool EnQueue(SqQueue &Q, int e) {
    if ((Q.rear + 1) % MAXSIZE == Q.front) // 队满判断
        return false;
    Q.data[Q.rear] = e;
    Q.rear = (Q.rear + 1) % MAXSIZE;  // 循环队列
    return true;
}

// 出队
bool DeQueue(SqQueue &Q, int &e) {
    if (Q.front == Q.rear)  // 队空判断
        return false;
    e = Q.data[Q.front];
    Q.front = (Q.front + 1) % MAXSIZE;  // 循环队列
    return true;
}

// 求队列长度
(Q.rear - Q.front + Maxsize) % Maxsize
```

## 链式队列

需要两个指针front和rear指向对头和队尾。

```c++
typedef struct QNode {
    Elemtype data;
    struct QNode* next;
} QNode;

// 初始化
void InitQueue(LinkQueue &Q) {
    Q.front = Q.rear = new QNode;  // 创建头结点
    Q.front->next = NULL;          // 头结点next置空
}

// 入队操作
void EnQueue(LinkQueue &Q, int e) {
    QNode* newNode = new QNode;
    newNode->data = e;
    newNode->next = NULL;
    Q.rear->next = newNode;  // 尾结点指向新结点
    Q.rear = newNode;        // 更新尾指针
}

// 出队操作
bool DeQueue(LinkQueue &Q, int &e) {
    if (Q.front == Q.rear) return false;
    QNode* temp = Q.front->next;  // 临时保存队头结点
    e = temp->data;
    Q.front->next = temp->next;
    if (Q.rear == temp)      // 如果删除的是最后一个结点
        Q.rear = Q.front;    // 队尾指针指向头结点
    delete temp;
    return true;
}
```

--------------

# 串

## 即字符串

一些概念

1. 串长：串中字符的个数。
2. 空串：0个字符的串，串长为0。
3. 子串：串中任意个连续的字符组成的子序列，称为该串的子串，原串称为子串的主串。
4. 空格串：全部由空格组成的串，空格串不是空串。

## 串的存储方式

#### 顺序存储3种方式

1、以 `'\0'` 表示字符串结束，\0不算字符长度。  

2、在0空间存储字符串的长度，下标为0的空间不使用。  
4abcd

3、结构体变量存储字符串长度。  

插入和删除需要移动大量元素。

#### 字符串链式存储

容易插入和删除，但是浪费空间

---------------------

# 树和森林

树是 n (n >= 0) 个节点的有限集合，当n=0时为空树；大于0为非空树。  

任意一棵非空树满足以下条件：  

1. 有且仅有一个称为根的节点。‘
2. 除根节点外，其余节点可分为 m (m > 0) 个互不相交的有限集合，每一个集合本身又是一棵树，并且称为根的子树。

## 树的名词：

1. 节点：节点包含数据元素及若干指向子树的分支信息。
2. 节点的度：节点拥有的子树个数。
3. 树的度：树中节点的最大度数。
4. 终端节点（叶子结点）：度为0的节点，又称为叶子。
5. 分支节点：度大于0的节点。除了叶子都是分支节点。
6. 内部节点：除了树根和叶子都是内部节点。
7. 节点的层次：从根到该节点的层数（根节点为第一层）。
8. 树的深度：所有节点的最大层数。
9. 路径：树中两个节点之间所经过的节点序列。
10. 路径长度：两节点之间路径上经过的边数。

## 树的基本性质：

1. **结点数** = 度数 + 1
2. **度为m的树**中，第i层至多有 **m^(i-1)** 个结点
3. **深度为h的m叉树**至多有 **(m^h - 1)/(m - 1)** 个结点
4. **具有n个结点的m叉树**的最小深度为 **⌈logₘ(n(m-1)+1)⌉**

## 树的存储：

双亲表示法：一个data域和一个指针域指向父节点

孩子表示法：一个data域和多个指向子节点的指针

孩子兄弟表示法：一个data域，一个指向第一个子节点的指针，一个指向右兄弟节点的指针

## 树的遍历(孩子兄弟表示法):

```c++
//先根遍历（先序遍历）
void PreOrderTraverse(CSTree T) {
    if (T) {
        cout << T->data << endl;          // 访问根结点
        PreOrderTraverse(T->firstchild);  // 遍历子树
        PreOrderTraverse(T->nextsibling); // 遍历兄弟
    }
}

//后根遍历（后序遍历）
void PostOrderTraverse(CSTree T) {
    if (T) {
        PostOrderTraverse(T->firstchild);  // 遍历子树
        cout << T->data << endl;           // 访问根结点
        PostOrderTraverse(T->nextsibling); // 遍历兄弟
    }
}
```



## 特殊的树：

二叉树：每个结点最多有两个子树的树结构。  
满二叉树：所有分支结点都有左右子树，且所有叶子都在同一层  
完全二叉树：深度为h，除第h层外，其它各层结点数都达到最大个数    
二叉搜索树：左子树所有结点值小于根结点，右子树所有结点值大于根结点

## 森林

**森林**是m（m≥0）棵**互不相交的树**的集合。

---------------

# 图

图是一种非常强大和灵活的非线性数据结构，用于表示物件与物件之间的关系。  
图中的元素关系是任意的，任意两个数据元素之间都可能相关。

#### 图的基本概念和术语

1. **顶点和边**
   - **顶点：** 图中的基本数据元素，也称为**节点**。
   - **边：** 连接两个顶点的线，表示它们之间的关系。边也称为**弧**。
2. **有向图和无向图**
   - **无向图：** 边没有方向。例如，Facebook的好友关系（A是B的朋友，B也一定是A的朋友）。边用 `(A, B)` 表示。
   - **有向图：** 边有方向。例如，Twitter的关注关系（A关注B，不代表B关注A）。边用 `<A, B>` 表示。
3. **权和网**
   - **权：** 边可以有一个数值，这个值称为权重。它可以代表距离、成本、时间等。
   - **网：** 带权重的图称为**带权图**或**网络**。
4. **路径和环**
   - **路径：** 从一个顶点到另一个顶点经过的边的序列。
   - **环：** 一条路径的起点和终点是同一个顶点。
5. **连通性**
   - **连通图（无向图）：** 图中任意两个顶点都是连通的（即存在路径）。
   - **强连通图（有向图）：** 图中任意两个顶点`A`和`B`，既存在从`A`到`B`的路径，也存在从`B`到`A`的路径。
6. **度和入度/出度**
   - **度（无向图）：** 一个顶点拥有的边数。
   - **入度（有向图）：** 指向该顶点的边的数量。
   - **出度（有向图）：** 从该顶点指出的边的数量。

#### 图的存储结构

1、**邻接矩阵**

- **原理：** 使用一个二维数组 `matrix` 来存储边。
  - 对于无向图：`matrix[i][j] = 1` 表示顶点 i 和 j 之间有边，`0` 则表示无边。无向图的邻接矩阵是**对称**的。
  - 对于有向图：`matrix[i][j] = 1` 表示存在从顶点 i 指向 j 的边。
  - 对于带权图：`matrix[i][j]` 存储权重，用无穷大（或一个特殊值）表示没有边。

2、**邻接表**

- **原理：** 为每个顶点建立一个单链表，链表中存储的是**与该顶点直接相连的邻接顶点**。
  - 通常用一个数组来存放所有链表的头指针。

#### 图的遍历算法

遍历图意味着访问图中的每一个顶点，且每个顶点只访问一次。这是图算法的基础。

1. **广度优先搜索**
   - **思想：** “一层一层”地访问。从起点开始，先访问所有邻接点，然后再访问这些邻接点的未被访问过的邻接点，以此类推。
   - **实现：** 通常使用**队列**来实现。
     - 将起点入队并标记为已访问。
     - 当队列不为空时，出队一个顶点并访问它，然后将该顶点的所有**未被访问的**邻接顶点入队并标记。
   - **应用：** 寻找最短路径（无权图）、社交网络中的“好友推荐”。
2. **深度优先搜索**
   - **思想：** “一条路走到黑”。从起点开始，沿着一条路径不断深入，直到没有未访问的邻接点，然后回溯到上一个顶点，继续探索下一条路径。
   - **实现：** 通常使用**递归**或**栈**来实现。
     - 访问当前顶点并标记为已访问。
     - 递归地访问该顶点的每一个未被访问的邻接顶点。
   - **应用：** 拓扑排序、检测图中是否存在环、寻找连通分量。
