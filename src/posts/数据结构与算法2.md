---
title: 算法
date: 2025-09-06 16:45:13
tags: 随笔
image: 'cover/cover-18.png'
---

# 算法

概念：对特定问题求解步骤的描述。  
通常以算法执行所消耗的时间和占用的空间来判断算法的优劣。

特点：  

1. 有穷性：总是在执行若干次后结束，不可能不停止。
2. 确定性：每条语句有确定的含义，无歧义。
3. 可行性：算法在当前环境条件下可以通过有限次运算实现。
4. 输入：有多个或0个输入。
5. 输出：有一个或多个输出。

时间复杂度：算法运行需要的时间，一般将算法基本运算的执行次数作为时间复杂度的度量标准。

--------------

# KMP算法

KMP算法是一种**字符串匹配算法**，用于在一个主文本串中查找一个模式串的出现位置。

- **暴力匹配缺点**：O(m*n)时间复杂度，效率低
- **KMP优势**：O(m+n)时间复杂度，利用已知信息避免重复比较

```text
假设有一串字符串：a b a a a b a b b
写出下标:        1 2 3 4 5 6 7 8 9
我们将1号设为0，再
1号和2号对比，a不等于b，取0
1号和3号对比，a=a，取1
因为上一位取1，这次从2号和4号对比，有ab不等于aa，再看1号和4号，取1
依次类推，到6号时，有1、2号等于5、6号，取2
7号时有aba = aba，取3
8号时ab = ab，取2
9号时，aba不等于abb，ab不等于bb，a不等于b，取0
得到PM(next)表：   0 0 1 1 1 2 3 2 0
不同的next表：     -1 0 0 1 1 1 2 3 2    (右移动1位,第一位为-1)
                  0 1 1 2 2 2 3 4 3     (第一个表+1)
```

 当匹配失败时，根据PM值决定模式串向右移动的距离：

示例：在位置6匹配失败（字符'b'）
next[5] = 2，说明可以跳过前面2个字符
直接从模式串的第3个字符开始继续匹配

```python
# 求next数组
def build_next(patt):
    next = [0]       # next数组，初始为0
    prefix_len = 0
    i = 1
    while i < len(patt):
        if patt[prefix_len] == patt[i]:
            prefix_len += 1
            next.append(prefix_len)
            i += 1
        else:
            if prefix_len == 0:
                next.append(0)
                i += 1
            else:
                prefix_len = next[prefix_len - 1]
	return next

# 匹配算法
def kmp_search(string,patt):
    next = build_next(patt)
    i = 0
    j = 0
    while i < len(string):
        if string[i] == patt[j]:
            i += 1
            j += 1
        elif j > 0:   # 字符不匹配，但j>0
            j = next[j-1]  # 关键：利用next数组跳转
        else:
            i += 1
        if j == len(patt):
            return i - j
    return -1      # 匹配失败
```

--------------

# Dijkstra（迪杰斯特拉）算法

Dijkstra算法是一种用于**寻找图中一个顶点（源点）到其他所有顶点的最短路径**的算法。它的核心思想是“贪心”和“广度优先搜索”，**特别适用于边权为非负数的图**。

**步骤如下：**

1. **初始化：**
   - 设置源点 `s` 的距离为 `0`（`dist[s] = 0`）。
   - 设置其他所有顶点的距离为**无穷大**（`∞`），表示我们暂时无法到达它们。
   - 将所有顶点放入集合 **U** 中。
   - 集合 **S** 初始为空。
2. **循环，直到U为空：**
   a. **选取：** 从集合U中选出**距离源点s最近**的顶点 `u`（也就是`dist[u]`最小的顶点）。
   b. **确认：** 将顶点 `u` 加入集合S。这意味着 `dist[u]` 就是 `s` 到 `u` 的最终最短距离。
   c. **更新（松弛操作）：** 遍历 `u` 的所有**未被确认**（仍在U中）的邻居顶点 `v`。
   \* 计算一条新的路径长度：`new_dist = dist[u] + weight(u, v)`
   \* 如果 `new_dist` 比当前记录的 `dist[v]` 更小，说明我们找到了一条更短的路径。
   \* 于是更新：`dist[v] = new_dist`
   \* （通常还会记录 `v` 的前驱顶点是 `u`，以便最后回溯出完整路径）

图解：  

![1](/img/1.png)

假设求a到其他点的最短路径，只需每次选择距离a最近的点

|        | 第一次 | 第二次  |  第三次   |   第四次    |    第五次     |
| :----: | :----: | :-----: | :-------: | :---------: | :-----------: |
|   b    |   2    |         |           |             |               |
|   c    |   5    |    3    |           |             |               |
|   d    |   ∞    |    5    |     5     |      5      |               |
|   e    |   ∞    |    ∞    |     7     |      7      |       6       |
|   f    |   ∞    |    ∞    |     4     |             |               |
| 终点集 | {a,b}  | {a,b,c} | {a,b,c,f} | {a,b,c,f,d} | {a,b,c,f,d,f} |

第一次，观察与a直接相连的点，得出长度信息，不直连的点标为无穷。

第二次，选择前一次最短的点(b)，记录从该点到其他点的路径长度，若长度比前一次短，就更新长度。最短的点不用再次记录。

第三次，新路径长度比前一次长则不用更新。

第四次，f点无连接的点，将前一次的数据复制。

-------------

# Floyd（弗洛伊德）算法

Floyd算法是一种用于**寻找图中任意两个顶点之间最短路径**的算法。它是一种“动态规划”算法，思想非常巧妙，直接基于图的邻接矩阵进行计算。

算法的核心思想是**动态规划**。它通过逐步允许使用更多的顶点作为“中转站”，来不断修正任意两点间的最短距离估计。

图解:

![1](/img/2.png)

首先准备两个二维数组

|  D   |  0   |  1   |  2   |  \|  | Path |  0   |  1   |  2   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  0   |  0   |  6   |  13  |  \|  |  0   |  -1  |  0   |  0   |
|  1   |  10  |  0   |  4   |  \|  |  1   |  1   |  -1  |  1   |
|  2   |  5   |  ∞   |  0   |  \|  |  2   |  2   |  -1  |  -1  |

D数组保存任意两个点之间最短路径的长度，初始为邻接矩阵的内容。

Path保存最短路径，没有最短路径用-1表示，初始为路径终点的前一个点。

接下来依次将每个点作为中间点更新数组。

|  D0  |  0   |  1   |  2   |  \|  | Path0 |  0   |  1   |  2   |
| :--: | :--: | :--: | :--: | :--: | :---: | :--: | :--: | :--: |
|  0   |  0   |  6   |  13  |  \|  |   0   |  -1  |  0   |  0   |
|  1   |  10  |  0   | `4`  |  \|  |   1   |  1   |  -1  | `1`  |
|  2   |  5   | `11` |  0   |  \|  |   2   |  2   | `0`  |  -1  |

第一次更新，以0作为中间点，若路径长度更短就进行更新。  
例如：D0数组中，1到0再到2，路径长度为10+13>4，不做更新。Path数组中相应位置也不变。  
2到0再到1，路径长度为5+6<∞，更新数组。Path数组的相应位置更新为终点的前一个点

之后依次以1、2...作为中间点更新数组，最后得出的D就是任意两点的最短距离。

--------------------------------

# 二分查找（Binary Search）

二分查找是一种**在有序数组中查找特定元素**的高效搜索算法。它通过不断将搜索区间减半来快速定位目标元素。

```python
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2  # 计算中间索引
        
        if arr[mid] == target:
            return mid             # 找到目标
        elif arr[mid] < target:
            left = mid + 1         # 在右半部分继续查找
        else:
            right = mid - 1        # 在左半部分继续查找
    return -1  # 目标不存在
```

-------------------------

# 插入排序（Insertion Sort）

插入排序是一种简单直观的排序算法，它的工作原理类似于我们整理扑克牌的方式：**逐个将元素插入到已排序序列的适当位置**。

1. 将数组分为**已排序**和**未排序**两部分
2. 初始时，已排序部分只有一个元素（第一个元素）
3. 依次将未排序部分的元素插入到已排序部分的正确位置
4. 重复直到所有元素都插入到正确位置

```c++
void insertionSort(std::vector<int>& arr) {
    int n = arr.size();
    for (int i = 1; i < n; i++) {
        int key = arr[i];  // 当前要插入的元素
        int j = i - 1;
        // 将比key大的元素向后移动
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        // 插入key到正确位置
        arr[j + 1] = key;
    }
}
```

# 希尔排序（Shell Sort）

希尔排序是插入排序的一种高效改进版本，由Donald Shell于1959年提出。它通过**分组插入排序**的方式，先让数组部分有序，最后再进行整体插入排序。

1. **分组插入**：将数组按一定间隔分组，对每组进行插入排序
2. **逐步缩小间隔**：每次排序后缩小间隔，直到间隔为1
3. **最终插入排序**：当间隔为1时，就是普通的插入排序

```c++
void shellSort(std::vector<int>& arr) {
    int n = arr.size();
    // 初始间隔：n/2, n/4, n/8, ..., 1
    for (int gap = n / 2; gap > 0; gap /= 2) {
        // 对每个间隔进行插入排序
        for (int i = gap; i < n; i++) {
            int temp = arr[i];
            int j;
            // 对分组进行插入排序
            for (j = i; j >= gap && arr[j - gap] > temp; j -= gap) {
                arr[j] = arr[j - gap];
            }
            arr[j] = temp;
        }
    }
}
```



# 冒泡排序（Bubble Sort）

冒泡排序是一种简单的排序算法，它重复地遍历要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。这个算法的名字由来是因为越小的元素会经由交换慢慢"浮"到数列的顶端。

1. **比较相邻元素**：从数组开始，比较相邻的两个元素
2. **交换位置**：如果顺序错误（前一个比后一个大），就交换它们
3. **重复遍历**：重复这个过程，每次遍历都会将当前最大的元素"冒泡"到正确位置
4. **提前终止**：如果某次遍历没有发生交换，说明数组已经有序

```c++
void bubbleSortOptimized(std::vector<int>& arr) {
    int n = arr.size();
    bool swapped;
    for (int i = 0; i < n - 1; i++) {
        swapped = false;
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                std::swap(arr[j], arr[j + 1]);
                swapped = true;
            }
        }
        // 如果这次遍历没有交换，说明已经有序
        if (!swapped) {
            break;
        }
    }
}
```

# 快速排序（Quick Sort）

快速排序是一种高效的排序算法，采用**分治策略**（Divide and Conquer）。由Tony Hoare于1959年发明，是实际应用中最快的通用排序算法之一。

1. **选择基准**（Pivot）：从数组中选择一个元素作为基准
2. **分区**（Partition）：重新排列数组，使所有比基准小的元素放在左边，比基准大的放在右边
3. **递归排序**：递归地对左右两个子数组进行快速排序

# 归并排序（Merge Sort）

归并排序是一种基于**分治策略**的高效排序算法，采用"分而治之"的思想。由John von Neumann于1945年发明，是第一个达到O(n log n)时间复杂度的排序算法。

1. **分解**：将数组递归地分成两半，直到每个子数组只有一个元素
2. **解决**：单个元素的数组自然是有序的
3. **合并**：将两个已排序的子数组合并成一个有序数组

```c++
void mergeSort(vector<int>& arr) {
    int n = arr.size();
    vector<int> temp(n);
    for (int size = 1; size < n; size *= 2) {
        for (int left = 0; left < n - 1; left += 2 * size) {
            int mid = min(left + size - 1, n - 1);
            int right = min(left + 2 * size - 1, n - 1);
            // 合并两个子数组
            int i = left, j = mid + 1, k = left;
            while (i <= mid && j <= right) {
                if (arr[i] <= arr[j]) {
                    temp[k++] = arr[i++];
                } else {
                    temp[k++] = arr[j++];
                }
            }
            // 复制剩余元素
            while (i <= mid) temp[k++] = arr[i++];
            while (j <= right) temp[k++] = arr[j++];
            // 将临时数组复制回原数组
            for (k = left; k <= right; k++) {
                arr[k] = temp[k];
            }
        }
    }
}
```

# 基数排序 (Radix Sort)

基数排序是一种非比较型整数排序算法，它通过将整数按位数切割成不同的数字，然后按每个位数分别比较。基数排序的时间复杂度为O(nk)，其中n是排序元素个数，k是数字位数。

1. 找到数组中的最大数，确定最大位数
2. 从最低位开始，对每一位进行计数排序或桶排序
3. 重复这个过程直到最高位

```c++
void radixSort(vector<int>& arr) {
    if (arr.empty()) return;
    
    int maxNum = *max_element(arr.begin(), arr.end());
    int maxDigits = 0;
    while (maxNum > 0) {
        maxDigits++;
        maxNum /= 10;
    }
    
    for (int exp = 1; maxDigits > 0; exp *= 10, maxDigits--) {
        // 创建10个桶
        vector<vector<int>> buckets(10);
        
        // 将元素分配到对应的桶中
        for (int num : arr) {
            int digit = (num / exp) % 10;
            buckets[digit].push_back(num);
        }
        
        // 从桶中收集元素
        int index = 0;
        for (int i = 0; i < 10; i++) {
            for (int num : buckets[i]) {
                arr[index++] = num;
            }
        }
    }
}
```

| 排序算法 | 平均时间复杂度 | 最坏时间复杂度 | 最好时间复杂度 | 空间复杂度 | 稳定性 | 适用场景                 |
| :------- | :------------- | :------------- | :------------- | :--------- | :----- | :----------------------- |
| 插入排序 | O(n²)          | O(n²)          | O(n)           | O(1)       | 稳定   | 小规模数据、基本有序数据 |
| 希尔排序 | O(n¹·³)        | O(n²)          | O(n)           | O(1)       | 不稳定 | 中等规模数据             |
| 冒泡排序 | O(n²)          | O(n²)          | O(n)           | O(1)       | 稳定   | 教学用途、小规模数据     |
| 快速排序 | O(n log n)     | O(n²)          | O(n log n)     | O(log n)   | 不稳定 | 大规模通用数据           |
| 归并排序 | O(n log n)     | O(n log n)     | O(n log n)     | O(n)       | 稳定   | 大规模数据、外部排序     |
| 基数排序 | O(nk)          | O(nk)          | O(nk)          | O(n+k)     | 稳定   | 整数排序、数字字符串     |
