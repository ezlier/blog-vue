---
title: C++面向对象(1)类与对象
date: 2025-08-24 12:40:31
tags: [C++,进阶]
image: 'cover/cover-16.jpg'
---

# 类

类，是 C++ 实现面向对象最基础的部分。类其实和之前学过的结构体十分相似，你可以认为类是结构体的升级版。

语法：

```c++
#include "iostream"
using namespace std;
//声明：class 类名{};
class Staff{
public:
    int a = 10;  //类的成员变量
    int b = 20;
    int c = 30;
};

int main(){
    //类的使用
    Staff st{1,2};//可以赋值
    cout << st.a << endl;
    cout << st.b << endl;
    cout << st.c << endl;
	
    //类也可以使用new和delete
    Staff *st1 = new Staff();
    delete st1;
    return 0;
}
```

--------------------------------------

# 成员函数

除了成员变量之外，类还提供了成员函数。

```c++
#include "iostream"
using namespace std;

class Ciallo{
public:
    void say_ciallo(){              //定义成员函数
        cout << "ciallo" << endl;
    }
};

int main(){
    Ciallo hi;
    hi.say_ciallo();               //调用函数
    return 0;
}
```

成员函数同样受到权限修饰符的限制，上面的例子中，函数写到了 public 下面，因此，我们可以在类的外部对其进行调用。而如果把他放到 private 里面，就不能被外部调用，只能被类中的其他函数调用。

### 成员函数的重载

成员函数的重载是指在同一个类中，函数名字相同，函数参数不同的函数。

```c++
class Ciallo{
public:
    void say_ciallo(){
        cout << "ciallo" << endl;
    }
    void say_ciallo(string i) {
        cout << i << endl;
    }
};
```

这个类中，我们定义了两个函数，都叫做 say_ciallo，但是他们的参数不一样，一个没有参数，一个参数是一个 int 类型的变量。这种情况下，两个函数都是有效的。而在调用的时候，C++ 会根据调用者传入的函数自行匹配相应的实现。

-----

# 构造函数和析构函数

类的**构造函数**是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。  
构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。

类的**析构函数**是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行。  
析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。

以下是一个在**类内被声明**的构造函数和析构函数：

```c++
#include "iostream"
using namespace std;

class Staff{
public:
    //构造函数
    Staff(){
        cout << "构造函数被调用" << endl;
    };
    //析构函数
    ~Staff(){
        cout << "析构函数被调用" << endl;
    };
};

int main(){
    Staff staff1;  //构造函数和析构函数会被自动执行
    return 0;
}
```

在**类外声明**的构造函数和析构函数：

```c++
#include "iostream"
using namespace std;

class Staff{
public:
    Staff();//构造函数声明
    ~Staff();//析构函数声明
};

Staff::Staff(void){
    cout << "构造函数被调用" << endl;
}
Staff::~Staff(void){
    cout << "析构函数被调用" << endl;
}

int main(){
    Staff staff1;  //构造函数和析构函数会被自动执行
    return 0;
}
```

------------------------

# 访问修饰符

访问修饰符用于指定类成员的访问权限。类成员的访问限制是通过在类主体内部对各个区域标记 `public、private、protected` 来指定的。一个类可以有多个 public、protected 或 private 标记区域。成员和类的默认访问修饰符是 private。

- private：用来指定私有成员。一个类的私有成员，不论是成员变量还是成员函数，都只能在该类的内部才能被访问。
- public：用来指定公有成员。一个类的公有成员在任何地方都可以被访问。
- protected：和私有成员类似，但是在子类可以访问。

```c++
class Staff{
public:
	int a;    //可以cout
private:
    int b;    //无法cout
};
```

----------------------------

# 运算符重载

看下面的代码

```c++
#include "iostream"
using namespace std;

class Staff{
public:
    int a = 10;
    int b = 20;
};

int main(){
    Staff st1;
    Staff st2;
    Staff st3;
    st3.a = st1.a + st2.a;
    st3.b = st1.b + st2.b;
    return 0;
}
```

我们可以用运算符重载的方式使两个对象直接相加。

```c++
#include "iostream"
using namespace std;

class Staff{
public:
    int a = 10;
    int b = 20;
    Staff operator+ (Staff &p){
        Staff temp;
        temp.a = this->a + p.a;
        temp.b = this->b + p.b;
        return temp;
    }
};

int main(){
    Staff st1;
    Staff st2;
    Staff st3;
    st3 = st1 + st2;
    cout << st3.a << endl << st3.b;
    return 0;
}
```

在上面的代码中`this`是第一参数，`&p`是第二参数，`+`对应`operator+`。

在C++中，大部分运算符都可以重载。

--------------------

# 多文件编程

我们在此之前都是把代码放到一个文件里，但是这样在实际工程中肯定是不行的，我们不可能把所有的代码都写到一个文件夹里面。而在 C++ 中我们就常常把类定义到不同的文件里面，把每个类都独立起来，这样代码的耦合性就会降低，方便维护。

在 C++ 中，我们可以把一个类写到两个文件里面，一个是后缀为 .h 或者 .hpp 的头文件，一个是后缀为 .cpp 的实现文件。

Staff.h 和 Staff.cpp。Staff.h 文件为定义，Staff.cpp 为实现。

在分了文件之后，我们想要在 main 函数中引用这个类，就需要使用 `#include “Staff.h”` 将头文件引入进来，然后才可以使用类。

例如：同一个文件夹中有 `main.cpp` 、 `demo.cpp` 和 `demo.h` 3个文件。

在 `demo.h` 中定义各种变量和函数：

```c++
int a;
int b;
...
void hello(){};
void hi(){};
...
```

在 `demo.cpp` 中赋值和写函数体：

```c++
#include "iostream"
#include "demo.h"   //需要引用头文件
using namespace std;
a = 1;
b = 2;
void hello(){
    cout << "hello";
}
void hi(){
    cout << "hi";
}
```

`main.cpp` 中：

```c++
#include "iostream"
#include "demo.h"   //需要引用头文件
using namespace std;

int main(){
    hello();
    hi();
    return 0;
}
```

注意：在此处使用g++手动编译文件时，需要把 `main.cpp` 和 `demo.cpp` 一起编译。
